"""
LabLeakFinder L4: Exploit Validator
Domain: Penetration Testing - Active Exploitation Phase (PenTest+ Domains 3-4)

Purpose:
    Validate identified vulnerabilities through active exploitation.
    Generate proof-of-concept demonstrations.
    Create exploit chains showing attack progression.
    Demonstrate real business impact of compromises.

Key Functions:
    - Load CRITICAL/HIGH findings from L3
    - Attempt exploitation of each vulnerability type
    - Proof-of-concept validation
    - Exploit chain mapping (e.g., backup file → credentials → admin)
    - P-Fuzzer integration for payload delivery
    - Impact assessment (data accessed, systems compromised)
    - Exploitation report generation

Integration:
    INPUT: L3 Findings (findings_report.json)
    INPUT: P-Fuzzer capabilities (payload generation, delivery)
    OUTPUT:
        - exploitation_report.json (detailed exploit attempts)
        - poc_demonstrations.md (proof-of-concept evidence)
        - exploit_chain_map.json (attack progression)
        - business_impact_assessment.html (executive view of compromise)

PenTest+ Alignment:
    - Domain 2: Information Gathering (L1/L2/L3 complete)
    - Domain 3: Vulnerability Identification (L3 complete)
    - Domain 4: Penetration Testing (L4 active exploitation) ← YOU ARE HERE
    - Domain 4: Social Engineering (included in chain scenarios)
    - Domain 5: Post-Exploitation (data exfiltration simulation)
    - Domain 6: Reporting & Communication (impact narrative)

Ethical Boundaries:
    - Lab environment only (vulnerable.lab, 192.168.x.x, *.local)
    - No actual credential theft or data exfiltration
    - Simulation mode: demonstrate vulnerability, not full compromise
    - All attempts logged for audit trail
"""

import json
import logging
import sys
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum
from collections import defaultdict
import hashlib
import base64

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s',
    handlers=[
        logging.FileHandler('labfinder_l4_detailed.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class ExploitStatus(Enum):
    """Status of an exploitation attempt."""
    SUCCESSFUL = "successful"
    PARTIAL = "partial"
    FAILED = "failed"
    NOT_ATTEMPTED = "not_attempted"

class ExploitChainStage(Enum):
    """Stage in an exploit chain progression."""
    RECONNAISSANCE = "reconnaissance"
    INITIAL_ACCESS = "initial_access"
    CREDENTIAL_ACQUISITION = "credential_acquisition"
    LATERAL_MOVEMENT = "lateral_movement"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PERSISTENCE = "persistence"
    DATA_EXFILTRATION = "data_exfiltration"

@dataclass
class ExploitAttempt:
    """Record of an exploitation attempt."""
    attempt_id: str
    finding_id: str
    vulnerability_type: str
    target_domain: str
    exploit_name: str
    exploit_description: str
    status: ExploitStatus
    evidence_of_compromise: str
    data_accessed: List[str]
    timestamp: str
    impact_severity: str
    remediation_validation: bool
    notes: str

@dataclass
class ExploitChain:
    """A chain of exploits leading to full compromise."""
    chain_id: str
    name: str
    description: str
    stages: List[Dict]
    total_impact: str
    business_consequence: str
    remediation_priority: str

class ExploitDatabase:
    """Database of known exploits mapped to vulnerability types."""
    
    def __init__(self):
        self.exploits = self._initialize_exploits()
        logger.info(f"Loaded {len(self.exploits)} exploit templates")
    
    def _initialize_exploits(self) -> Dict:
        """Initialize known exploits by vulnerability type."""
        return {
            "directory_listing": {
                "exploit_name": "Directory Enumeration & File Access",
                "exploit_description": "Enumerate directory structure to discover sensitive files and folders",
                "attack_technique": "MITRE ATT&CK T1083 (File and Directory Discovery)",
                "steps": [
                    "Request directory listing (e.g., GET /uploads/)",
                    "Parse directory structure for sensitive folders",
                    "Attempt access to discovered files",
                    "Extract sensitive information (configs, credentials)"
                ],
                "success_indicators": [
                    "Directory listing visible",
                    "Sensitive files accessible without authentication",
                    "Configuration or backup files discovered"
                ],
                "data_at_risk": ["source code", "configuration files", "backup data", "API keys"],
                "impact": "High - allows discovery of sensitive assets"
            },
            "backup_file": {
                "exploit_name": "Backup File Retrieval & Credential Extraction",
                "exploit_description": "Access backup files to extract credentials, source code, and configurations",
                "attack_technique": "MITRE ATT&CK T1005 (Data from Local System)",
                "steps": [
                    "Identify backup file extensions (.bak, .backup, .old)",
                    "Request backup files from web root",
                    "Download and extract backup content",
                    "Parse for credentials, API keys, database configs",
                    "Use extracted credentials for lateral movement"
                ],
                "success_indicators": [
                    "Backup files downloaded successfully",
                    "Credentials extracted from backup",
                    "Sensitive configuration data visible"
                ],
                "data_at_risk": ["database credentials", "API keys", "source code", "encryption keys"],
                "impact": "CRITICAL - direct path to credential acquisition"
            },
            "config_file": {
                "exploit_name": "Configuration File Analysis & Secret Extraction",
                "exploit_description": "Access configuration files containing credentials and system details",
                "attack_technique": "MITRE ATT&CK T1552 (Unsecured Credentials)",
                "steps": [
                    "Identify config file paths (.conf, .config, .ini, .env, web.config)",
                    "Request configuration files directly",
                    "Parse for database credentials, API keys, encryption keys",
                    "Extract connection strings and authentication tokens",
                    "Use credentials to compromise application and databases"
                ],
                "success_indicators": [
                    "Config file accessible",
                    "Credentials visible in plaintext",
                    "Database connection strings obtained",
                    "API keys or tokens exposed"
                ],
                "data_at_risk": ["database credentials", "API keys", "encryption keys", "OAuth tokens"],
                "impact": "CRITICAL - enables full system compromise"
            },
            "debug_info": {
                "exploit_name": "Information Disclosure via Debug Output",
                "exploit_description": "Extract sensitive information from debug messages, stack traces, and error pages",
                "attack_technique": "MITRE ATT&CK T1589 (Information Gathering)",
                "steps": [
                    "Trigger errors to generate debug output",
                    "Parse stack traces for file paths and function names",
                    "Extract application version information",
                    "Identify database type and version",
                    "Research known CVEs for identified versions"
                ],
                "success_indicators": [
                    "Debug information visible",
                    "Stack traces reveal code structure",
                    "Application/database versions disclosed",
                    "File system paths revealed"
                ],
                "data_at_risk": ["application source paths", "version info", "database structure", "code logic"],
                "impact": "High - enables targeted exploitation"
            },
            "admin_panel": {
                "exploit_name": "Default Credentials & Authentication Bypass",
                "exploit_description": "Access administrative interfaces using default or weak credentials",
                "attack_technique": "MITRE ATT&CK T1110 (Brute Force) / T1078 (Valid Accounts)",
                "steps": [
                    "Identify admin panel location (/admin, /management, /control)",
                    "Attempt default credentials (admin/admin, admin/password)",
                    "Check for password reset functionality",
                    "Test for SQL injection in login form",
                    "Gain administrative access and control application"
                ],
                "success_indicators": [
                    "Admin panel accessed",
                    "Default credentials successful",
                    "Administrative functions available",
                    "Application settings and user data accessible"
                ],
                "data_at_risk": ["user data", "application settings", "source code access", "database access"],
                "impact": "CRITICAL - full application compromise"
            },
            "version_disclosure": {
                "exploit_name": "Version-Based Exploitation",
                "exploit_description": "Use disclosed version information to research and execute known vulnerabilities",
                "attack_technique": "MITRE ATT&CK T1592 (Gather Victim Host Information)",
                "steps": [
                    "Extract version from HTTP headers, banners, or error messages",
                    "Query CVE databases for known vulnerabilities in identified version",
                    "Download exploit code from public repositories",
                    "Execute exploit against target",
                    "Gain code execution or system access"
                ],
                "success_indicators": [
                    "Version identified",
                    "Known CVE found for version",
                    "Exploit code available",
                    "Successful exploitation of known vulnerability"
                ],
                "data_at_risk": ["system files", "source code", "user data", "system configuration"],
                "impact": "Medium-High - depends on specific CVE severity"
            }
        }
    
    def get_exploit(self, vulnerability_type: str) -> Optional[Dict]:
        """Retrieve exploit template for vulnerability type."""
        return self.exploits.get(vulnerability_type)

class ExploitValidator:
    """
    Validates vulnerabilities through active exploitation.
    
    Implements:
    - Load findings from L3
    - Attempt exploitation of each finding
    - Generate proof-of-concept demonstrations
    - Map exploit chains
    - Calculate business impact
    """
    
    def __init__(self, findings_file: str = "findings_report.json"):
        self.db = ExploitDatabase()
        self.findings = self._load_findings(findings_file)
        self.exploit_attempts = []
        self.exploit_chains = []
        self.attempt_counter = 0
        
        logger.info(f"ExploitValidator initialized with {len(self.findings)} findings")
    
    def _load_findings(self, filename: str) -> List[Dict]:
        """Load findings from L3 result analyzer."""
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
                # Filter for CRITICAL and HIGH severity findings only
                all_findings = data.get('findings', [])
                critical_findings = [
                    f for f in all_findings 
                    if f.get('cvss_severity') in ['CRITICAL', 'HIGH']
                ]
                logger.info(f"Loaded {len(critical_findings)} CRITICAL/HIGH findings for exploitation")
                return critical_findings
        except FileNotFoundError:
            logger.error(f"Findings file not found: {filename}")
            return []
    
    def _simulate_exploit_execution(self, finding: Dict, exploit: Dict) -> Tuple[ExploitStatus, str, List[str]]:
        """
        Simulate exploitation attempt.
        
        In production, this would execute real exploit code.
        For lab purposes, we simulate based on vulnerability type and exploit technique.
        """
        exposure_type = finding.get('exposure_type')
        target_domain = finding.get('target_domain')
        
        # Simulated data that would be accessed through exploitation
        simulated_access = {
            "directory_listing": (
                ExploitStatus.SUCCESSFUL,
                f"Successfully enumerated {target_domain}/uploads directory.\n"
                f"Discovered: configs/, backups/, private/\n"
                f"Accessed backup_2024.sql (45MB)\n"
                f"Evidence: Directory listing with 15+ sensitive files visible",
                ["source_code", "backup_databases", "configuration_files"]
            ),
            "backup_file": (
                ExploitStatus.SUCCESSFUL,
                f"Retrieved backup file: application.conf.bak\n"
                f"Extracted credentials:\n"
                f"  Database: root/MyS3cr3tP@ss\n"
                f"  API Key: sk-proj-abc123def456\n"
                f"  Encryption Key: base64_encoded_secret",
                ["database_credentials", "api_keys", "encryption_keys", "source_code"]
            ),
            "config_file": (
                ExploitStatus.SUCCESSFUL,
                f"Accessed /var/www/html/.env file\n"
                f"Retrieved configuration:\n"
                f"  DB_HOST=192.168.1.10\n"
                f"  DB_USER=app_user\n"
                f"  DB_PASS=weak_password_123\n"
                f"  API_KEY=sk-live-abcdef\n"
                f"  JWT_SECRET=my_super_secret",
                ["database_connection_strings", "api_credentials", "jwt_secrets", "server_ips"]
            ),
            "debug_info": (
                ExploitStatus.PARTIAL,
                f"Captured debug information:\n"
                f"  Application: WordPress 5.8.1\n"
                f"  PHP Version: 7.4.3\n"
                f"  MySQL Version: 5.7.30\n"
                f"  File Path: /var/www/html/wp-content/\n"
                f"  Stack Trace revealed: wp-admin/includes/user.php",
                ["application_version", "database_version", "file_paths"]
            ),
            "admin_panel": (
                ExploitStatus.SUCCESSFUL,
                f"Admin panel at {target_domain}/admin/ accessed\n"
                f"Default credentials admin:admin successful\n"
                f"Logged in as Administrator\n"
                f"Full application control achieved",
                ["admin_access", "user_database", "application_settings", "system_commands"]
            ),
            "version_disclosure": (
                ExploitStatus.PARTIAL,
                f"Disclosed version: Apache 2.4.41 (Ubuntu)\n"
                f"CVE-2021-41773 applies (Path Traversal)\n"
                f"Exploit code available in public repositories\n"
                f"Potential for remote code execution if combined with file upload",
                ["version_info", "known_cve_mapping", "exploit_availability"]
            )
        }
        
        return simulated_access.get(exposure_type, (ExploitStatus.FAILED, "No exploit available", []))
    
    def exploit_findings(self) -> List[ExploitAttempt]:
        """Attempt exploitation of all CRITICAL/HIGH findings."""
        logger.info(f"Beginning exploitation phase against {len(self.findings)} findings")
        
        for finding in self.findings:
            exposure_type = finding.get('exposure_type')
            exploit_template = self.db.get_exploit(exposure_type)
            
            if not exploit_template:
                logger.warning(f"No exploit available for {exposure_type}")
                continue
            
            # Simulate exploitation
            status, evidence, data_accessed = self._simulate_exploit_execution(finding, exploit_template)
            
            self.attempt_counter += 1
            attempt = ExploitAttempt(
                attempt_id=f"EXPL-{self.attempt_counter:04d}",
                finding_id=finding.get('finding_id'),
                vulnerability_type=exposure_type,
                target_domain=finding.get('target_domain'),
                exploit_name=exploit_template.get('exploit_name'),
                exploit_description=exploit_template.get('exploit_description'),
                status=status,
                evidence_of_compromise=evidence,
                data_accessed=data_accessed,
                timestamp=datetime.now().isoformat(),
                impact_severity=finding.get('cvss_severity'),
                remediation_validation=False,
                notes=f"MITRE Technique: {exploit_template.get('attack_technique')}"
            )
            
            self.exploit_attempts.append(attempt)
            logger.info(f"[EXPLOIT] {attempt.attempt_id}: {exploit_template['exploit_name']} - {status.value}")
        
        logger.info(f"Exploitation phase complete. {len(self.exploit_attempts)} attempts performed.")
        return self.exploit_attempts
    
    def map_exploit_chains(self) -> List[ExploitChain]:
        """Map chains of exploits showing progression to full compromise."""
        logger.info("Mapping exploit chains for attack progression scenarios")
        
        # Chain 1: Backup file → Credentials → Admin access
        if any(a.vulnerability_type == "backup_file" for a in self.exploit_attempts):
            chain1 = ExploitChain(
                chain_id="CHAIN-001",
                name="Backup Disclosure to Admin Compromise",
                description="Attacker discovers and accesses backup file, extracts credentials, gains admin access",
                stages=[
                    {
                        "stage": ExploitChainStage.RECONNAISSANCE.value,
                        "action": "Directory listing reveals backup files",
                        "exploit_id": next((a.attempt_id for a in self.exploit_attempts 
                                          if a.vulnerability_type == "directory_listing"), None)
                    },
                    {
                        "stage": ExploitChainStage.INITIAL_ACCESS.value,
                        "action": "Download backup file (application.conf.bak)",
                        "exploit_id": next((a.attempt_id for a in self.exploit_attempts 
                                          if a.vulnerability_type == "backup_file"), None)
                    },
                    {
                        "stage": ExploitChainStage.CREDENTIAL_ACQUISITION.value,
                        "action": "Extract database credentials from backup",
                        "data_obtained": "db_user: admin, db_pass: MyS3cr3tP@ss"
                    },
                    {
                        "stage": ExploitChainStage.LATERAL_MOVEMENT.value,
                        "action": "Use credentials to access admin panel",
                        "exploit_id": next((a.attempt_id for a in self.exploit_attempts 
                                          if a.vulnerability_type == "admin_panel"), None)
                    },
                    {
                        "stage": ExploitChainStage.PERSISTENCE.value,
                        "action": "Create backdoor admin account",
                        "data_obtained": "backdoor_user: attacker, password: complex_hash"
                    }
                ],
                total_impact="Full application and database compromise",
                business_consequence="Attacker has complete control over application, can access all user data, modify records, install malware",
                remediation_priority="CRITICAL - remediate all findings in chain immediately"
            )
            self.exploit_chains.append(chain1)
        
        # Chain 2: Config file → Credentials → Database compromise
        if any(a.vulnerability_type == "config_file" for a in self.exploit_attempts):
            chain2 = ExploitChain(
                chain_id="CHAIN-002",
                name="Configuration File to Database Compromise",
                description="Attacker accesses config file, extracts DB credentials, gains database access",
                stages=[
                    {
                        "stage": ExploitChainStage.RECONNAISSANCE.value,
                        "action": "Identify config file locations (.env, web.config, config.php)",
                        "technique": "Common file path enumeration"
                    },
                    {
                        "stage": ExploitChainStage.INITIAL_ACCESS.value,
                        "action": "Access .env file from web root",
                        "exploit_id": next((a.attempt_id for a in self.exploit_attempts 
                                          if a.vulnerability_type == "config_file"), None)
                    },
                    {
                        "stage": ExploitChainStage.CREDENTIAL_ACQUISITION.value,
                        "action": "Extract database credentials and connection strings",
                        "data_obtained": "DB_HOST: 192.168.1.10, DB_USER: app_user, DB_PASS: weak_password_123"
                    },
                    {
                        "stage": ExploitChainStage.PRIVILEGE_ESCALATION.value,
                        "action": "Connect to database with extracted credentials",
                        "command": "mysql -h 192.168.1.10 -u app_user -p weak_password_123"
                    },
                    {
                        "stage": ExploitChainStage.DATA_EXFILTRATION.value,
                        "action": "Exfiltrate sensitive data (users table, credit cards, PII)",
                        "data_obtained": "100,000+ user records with emails, passwords, addresses"
                    }
                ],
                total_impact="Full database compromise and data breach",
                business_consequence="Breach of 100,000+ user records, regulatory violations (GDPR/CCPA), loss of customer trust, legal liability",
                remediation_priority="CRITICAL - immediate incident response required"
            )
            self.exploit_chains.append(chain2)
        
        # Chain 3: Version disclosure → Known CVE → RCE
        if any(a.vulnerability_type == "version_disclosure" for a in self.exploit_attempts):
            chain3 = ExploitChain(
                chain_id="CHAIN-003",
                name="Version Disclosure to Remote Code Execution",
                description="Attacker identifies version, researches CVEs, executes known exploit for RCE",
                stages=[
                    {
                        "stage": ExploitChainStage.RECONNAISSANCE.value,
                        "action": "Extract version from HTTP headers, banners",
                        "exploit_id": next((a.attempt_id for a in self.exploit_attempts 
                                          if a.vulnerability_type == "version_disclosure"), None)
                    },
                    {
                        "stage": ExploitChainStage.RECONNAISSANCE.value,
                        "action": "Query CVE databases for known vulnerabilities",
                        "result": "CVE-2021-41773, CVE-2022-12345 applicable to version"
                    },
                    {
                        "stage": ExploitChainStage.INITIAL_ACCESS.value,
                        "action": "Download exploit code from public repositories (exploit-db, GitHub)",
                        "result": "POC available, tested against this version"
                    },
                    {
                        "stage": ExploitChainStage.PRIVILEGE_ESCALATION.value,
                        "action": "Execute exploit payload against vulnerable service",
                        "command": "python3 cve_2021_41773_exploit.py --target vulnerable.lab"
                    },
                    {
                        "stage": ExploitChainStage.PERSISTENCE.value,
                        "action": "Achieve remote code execution, install reverse shell",
                        "access": "Full system access as web server user (www-data)"
                    }
                ],
                total_impact="Complete system compromise with code execution",
                business_consequence="Attacker can install malware, create botnets, use server for lateral attacks, encrypt data for ransomware",
                remediation_priority="CRITICAL - patch vulnerable software immediately"
            )
            self.exploit_chains.append(chain3)
        
        logger.info(f"Mapped {len(self.exploit_chains)} exploit chains")
        return self.exploit_chains
    
    def get_exploitation_summary(self) -> Dict:
        """Generate summary statistics of exploitation attempts."""
        successful = sum(1 for a in self.exploit_attempts if a.status == ExploitStatus.SUCCESSFUL)
        partial = sum(1 for a in self.exploit_attempts if a.status == ExploitStatus.PARTIAL)
        failed = sum(1 for a in self.exploit_attempts if a.status == ExploitStatus.FAILED)
        
        total_data_at_risk = set()
        for attempt in self.exploit_attempts:
            total_data_at_risk.update(attempt.data_accessed)
        
        return {
            "total_attempts": len(self.exploit_attempts),
            "successful": successful,
            "partial": partial,
            "failed": failed,
            "success_rate": f"{(successful / len(self.exploit_attempts) * 100):.1f}%" if self.exploit_attempts else "0%",
            "total_exploit_chains": len(self.exploit_chains),
            "data_types_at_risk": sorted(list(total_data_at_risk)),
            "critical_systems_compromised": ["application", "database", "admin_panel"],
            "business_impact": "Full infrastructure compromise possible"
        }
    
    def export_exploitation_report(self, filename: str = "exploitation_report.json") -> None:
        """Export detailed exploitation report."""
        report = {
            "report_generated": datetime.now().isoformat(),
            "exploitation_phase": "Active Exploitation Validation",
            "summary": self.get_exploitation_summary(),
            "exploitation_attempts": [
                {
                    "attempt_id": a.attempt_id,
                    "finding_id": a.finding_id,
                    "vulnerability_type": a.vulnerability_type,
                    "target_domain": a.target_domain,
                    "exploit_name": a.exploit_name,
                    "status": a.status.value,
                    "evidence": a.evidence_of_compromise,
                    "data_accessed": a.data_accessed,
                    "cvss_severity": a.impact_severity,
                    "mitre_technique": a.notes,
                    "timestamp": a.timestamp
                }
                for a in self.exploit_attempts
            ],
            "exploit_chains": [
                {
                    "chain_id": c.chain_id,
                    "name": c.name,
                    "description": c.description,
                    "stages": c.stages,
                    "total_impact": c.total_impact,
                    "business_consequence": c.business_consequence,
                    "remediation_priority": c.remediation_priority
                }
                for c in self.exploit_chains
            ]
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Exported exploitation report to {filename}")
    
    def export_poc_demonstrations(self, filename: str = "poc_demonstrations.md") -> None:
        """Export proof-of-concept demonstrations in markdown format."""
        poc_md = f"""# LabLeakFinder - Proof of Concept Demonstrations

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}

## Executive Summary

This document provides proof-of-concept evidence that vulnerabilities identified in the LabLeakFinder L3 assessment can be **actively exploited** to compromise the target environment.

**Key Findings:**
- **{self.get_exploitation_summary()['successful']}** vulnerabilities successfully exploited
- **{len(self.exploit_chains)}** attack chains mapped to full infrastructure compromise
- **Business Impact:** {self.get_exploitation_summary()['business_impact']}

---

## Detailed Proof of Concepts

"""
        
        for attempt in sorted(self.exploit_attempts, key=lambda x: x.impact_severity):
            poc_md += f"""
### PoC {attempt.attempt_id}: {attempt.exploit_name}

**Vulnerability:** {attempt.vulnerability_type.upper()}
**Target:** {attempt.target_domain}
**Status:** {attempt.status.value.upper()}
**Severity:** {attempt.impact_severity}

#### Exploitation Steps

1. Identify target: `{attempt.target_domain}`
2. Execute exploit: `{attempt.exploit_name}`
3. Obtain access: See evidence below

#### Evidence of Compromise

```
{attempt.evidence_of_compromise}
```

#### Data Accessed
"""
            for data in attempt.data_accessed:
                poc_md += f"- `{data}`\n"
            
            poc_md += f"""

#### MITRE ATT&CK Mapping
{attempt.notes}

#### Business Impact
Successful exploitation grants attacker access to: {', '.join(attempt.data_accessed)}

---
"""
        
        poc_md += f"""

## Exploit Chain Attack Scenarios

These chains demonstrate how vulnerabilities can be chained together to achieve complete infrastructure compromise:

"""
        
        for chain in self.exploit_chains:
            poc_md += f"""
### {chain.chain_id}: {chain.name}

**Description:** {chain.description}

**Attack Progression:**
"""
            for i, stage in enumerate(chain.stages, 1):
                poc_md += f"\n**Stage {i}: {stage.get('stage', 'Unknown').upper()}**\n"
                poc_md += f"- Action: {stage.get('action', 'N/A')}\n"
                if stage.get('data_obtained'):
                    poc_md += f"- Data Obtained: {stage['data_obtained']}\n"
                if stage.get('command'):
                    poc_md += f"- Command: `{stage['command']}`\n"
            
            poc_md += f"""

**Total Impact:** {chain.total_impact}

**Business Consequence:** {chain.business_consequence}

**Remediation Priority:** {chain.remediation_priority}

---
"""
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(poc_md)
        
        logger.info(f"Exported PoC demonstrations to {filename}")

def main():
    """Demonstrate L4 Exploit Validator functionality."""
    
    logger.info("=" * 80)
    logger.info("LabLeakFinder - L4 Exploit Validator")
    logger.info("Domain: Penetration Testing - Active Exploitation Phase")
    logger.info("=" * 80)
    
    validator = ExploitValidator(findings_file="findings_report.json")
    
    logger.info("\n" + "=" * 80)
    logger.info("PHASE 1: EXPLOITATION ATTEMPTS")
    logger.info("=" * 80)
    
    exploits = validator.exploit_findings()
    
    logger.info("\n" + "=" * 80)
    logger.info("PHASE 2: EXPLOIT CHAIN MAPPING")
    logger.info("=" * 80)
    
    chains = validator.map_exploit_chains()
    
    for chain in chains:
        logger.info(f"\n[CHAIN] {chain.chain_id}: {chain.name}")
        logger.info(f"  Stages: {len(chain.stages)}")
        logger.info(f"  Impact: {chain.total_impact}")
        logger.info(f"  Business Consequence: {chain.business_consequence}")
    
    logger.info("\n" + "=" * 80)
    logger.info("PHASE 3: EXPLOITATION SUMMARY")
    logger.info("=" * 80)
    
    summary = validator.get_exploitation_summary()
    logger.info(f"\nTotal Exploitation Attempts: {summary['total_attempts']}")
    logger.info(f"Successful Exploits: {summary['successful']}")
    logger.info(f"Partial Success: {summary['partial']}")
    logger.info(f"Failed: {summary['failed']}")
    logger.info(f"Success Rate: {summary['success_rate']}")
    logger.info(f"\nExploit Chains Mapped: {summary['total_exploit_chains']}")
    logger.info(f"Data Types at Risk: {', '.join(summary['data_types_at_risk'])}")
    logger.info(f"Business Impact: {summary['business_impact']}")
    
    logger.info("\n" + "=" * 80)
    logger.info("PHASE 4: REPORT GENERATION")
    logger.info("=" * 80)
    
    validator.export_exploitation_report("exploitation_report.json")
    validator.export_poc_demonstrations("poc_demonstrations.md")
    
    logger.info("\n✓ exploitation_report.json - Detailed exploitation data")
    logger.info("✓ poc_demonstrations.md - Proof-of-concept evidence with attack chains")
    
    logger.info("\n" + "=" * 80)
    logger.info("L4 Exploit Validator Complete")
    logger.info("Ready for Post-Exploitation and Reporting Phase")
    logger.info("=" * 80)

if __name__ == "__main__":
    main()
